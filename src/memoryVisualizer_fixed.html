<!DOCTYPE html>
<html>
<head>
    <title>Memory Allocation Visualizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        h2 {
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }        .memory-grid {
            display: grid;
            grid-template-columns: repeat(25, 1fr);
            gap: 3px;
            margin-bottom: 20px;
            min-height: 300px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }        .block {
            width: 28px;
            height: 28px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            position: relative;
            cursor: pointer;
        }
        
        .block:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.7);
            filter: brightness(1.1);
        }
        
        .block.empty {
            background-color: #f0f0f0;
        }
        .block.allocated {
            background-color: #4CAF50;
            color: white;
        }
        .block.indexed {
            background-color: #2196F3;
            color: white;
        }
        .block.index-block {
            background-color: #FF9800;
            color: white;
            border: 2px solid #E65100;
        }
        .block.linked {
            background-color: #9C27B0;
            color: white;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-item.block-info {
            margin-left: auto;
            background-color: #e9f5ff;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border: 1px solid #ccc;
        }
        .legend-color.empty {
            background-color: #f0f0f0;
        }
        .legend-color.allocated {
            background-color: #4CAF50;
        }
        .legend-color.indexed {
            background-color: #2196F3;
        }
        .legend-color.index-block {
            background-color: #FF9800;
        }
        .legend-color.linked {
            background-color: #9C27B0;
        }
        .stats {
            margin-top: 15px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }
        .refresh-btn, .test-btn {
            padding: 8px 16px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .refresh-btn {
            background-color: #2196F3;
        }
        .test-btn {
            background-color: #FF9800;
        }
        .test-status {
            margin-left: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
        }
        .test-status.success {
            background-color: rgba(76, 175, 80, 0.2);
            color: #2E7D32;
        }
        .test-status.error {
            background-color: rgba(244, 67, 54, 0.2);
            color: #C62828;
        }
        .test-status.running {
            background-color: rgba(255, 152, 0, 0.2);
            color: #EF6C00;
        }
        .search-sort-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .search-input, .sort-select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .search-input {
            width: 180px;
        }
        .sort-select {
            min-width: 140px;
        }
        .file-info {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .file-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }        .tooltip {
            position: absolute;
            background-color: rgba(33, 33, 33, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            max-width: 350px;
            line-height: 1.5;
            backdrop-filter: blur(2px);
        }
        
        .tooltip strong {
            color: #ffeb3b;
            font-weight: bold;
        }
        
        .tooltip div {
            margin-bottom: 3px;
        }
    </style>
</head>
<body>
    <h2>Memory Allocation Visualizer</h2>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color empty"></div>
            <span>Empty Block</span>
        </div>
        <div class="legend-item">
            <div class="legend-color allocated"></div>
            <span>Contiguous Block</span>
        </div>
        <div class="legend-item">
            <div class="legend-color linked"></div>
            <span>Linked Block</span>
        </div>
        <div class="legend-item">
            <div class="legend-color indexed"></div>
            <span>Indexed Data Block</span>
        </div>
        <div class="legend-item">
            <div class="legend-color index-block"></div>
            <span>Index Block</span>
        </div>
        <div class="legend-item block-info">
            <span>1 Block = 1 KB (1024 bytes)</span>
        </div>
    </div>
    
    <div class="action-buttons">
        <button class="refresh-btn" id="refresh">Refresh View</button>
        <button class="test-btn" id="runTest">Run Test</button>
        <div id="testStatus" class="test-status"></div>
    </div>
    
    <div class="container">        <div class="stats" id="stats">
            <div class="stats-section">
                <h3>Storage Overview</h3>
                <div>Total Blocks: <span id="totalBlocks">0</span> (<span id="totalSizeKB">0</span> KB)</div>
                <div>Used Blocks: <span id="usedBlocks">0</span> (<span id="usedPercent">0%</span>)</div>
                <div>Free Blocks: <span id="freeBlocks">0</span> (<span id="freePercent">0%</span>)</div>
                <div>Fragmentation: <span id="fragmentation">0%</span></div>
            </div>
            
            <div class="stats-section">
                <h3>Allocation Breakdown</h3>
                <div class="allocation-stat contiguous">
                    <div class="allocation-label">Contiguous Blocks:</div> 
                    <div class="allocation-value"><span id="contiguousBlocks">0</span></div>
                </div>
                <div class="allocation-stat linked">
                    <div class="allocation-label">Linked Blocks:</div> 
                    <div class="allocation-value"><span id="linkedBlocks">0</span></div>
                </div>
                <div class="allocation-stat indexed">
                    <div class="allocation-label">Indexed Data Blocks:</div> 
                    <div class="allocation-value"><span id="indexedDataBlocks">0</span></div>
                </div>
                <div class="allocation-stat index-block">
                    <div class="allocation-label">Index Blocks:</div> 
                    <div class="allocation-value"><span id="indexBlocks">0</span></div>
                </div>
            </div>
        </div>
        
        <div class="memory-grid" id="memoryGrid">
            <!-- Memory blocks will be generated here -->
        </div>
        
        <div class="file-info" id="fileInfo">
            <div class="file-controls">
                <h3>File Allocation Information</h3>
                <div class="search-sort-container">
                    <input type="text" id="fileSearch" placeholder="Search files..." class="search-input">
                    <select id="fileSort" class="sort-select">
                        <option value="name">Sort by Name</option>
                        <option value="size">Sort by Size</option>
                        <option value="strategy">Sort by Strategy</option>
                        <option value="blocks">Sort by Blocks Used</option>
                    </select>
                </div>
            </div>
            <div id="fileList">
                <!-- File allocation info will be shown here -->
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        const { ipcRenderer } = require('electron');
        const memoryTest = require('./testMemoryVisualizer.js');
        
        // Get elements
        const memoryGridEl = document.getElementById('memoryGrid');
        const statsEl = document.getElementById('stats');
        const totalBlocksEl = document.getElementById('totalBlocks');
        const usedBlocksEl = document.getElementById('usedBlocks');
        const freeBlocksEl = document.getElementById('freeBlocks');
        const fragmentationEl = document.getElementById('fragmentation');
        const contiguousBlocksEl = document.getElementById('contiguousBlocks');
        const linkedBlocksEl = document.getElementById('linkedBlocks');
        const indexedDataBlocksEl = document.getElementById('indexedDataBlocks');
        const indexBlocksEl = document.getElementById('indexBlocks');
        const fileListEl = document.getElementById('fileList');
        const refreshBtn = document.getElementById('refresh');
        const runTestBtn = document.getElementById('runTest');
        const testStatusEl = document.getElementById('testStatus');
        const tooltipEl = document.getElementById('tooltip');
        const fileSearchEl = document.getElementById('fileSearch');
        const fileSortEl = document.getElementById('fileSort');
        
        // Store file data for filtering and sorting
        let fileData = [];
        
        // Initialize memory grid
        function renderMemoryGrid(memoryData) {
            memoryGridEl.innerHTML = '';
            
            const { blocks, files } = memoryData;
            const totalBlocks = blocks.length;
            let usedBlocks = 0;
            let fragmentCount = 0;
            let wasLastEmpty = true; // Start with true to not count the first allocated block as fragmentation
              console.log('Memory Grid: Total Blocks to render:', blocks.length);
            console.log('Blocks Data:', blocks);
              // Debug linked allocation blocks
            console.log('Debug - Files with linked allocation:');
            let linkedFiles = 0;
            let totalLinkedBlocks = 0;
            
            Object.keys(files).forEach(filePath => {
                const fileInfo = files[filePath];
                if (fileInfo.allocation && fileInfo.allocation.strategy === 'linked') {
                    linkedFiles++;
                    console.log('File:', filePath);
                    console.log('Linked blocks:', fileInfo.allocation.blocks);
                    console.log('Block count:', fileInfo.allocation.blocks.length);
                    totalLinkedBlocks += fileInfo.allocation.blocks.length;
                }
            });
            
            console.log(`Found ${linkedFiles} files using linked allocation with ${totalLinkedBlocks} total linked blocks`);
            
            // Debug allocation strategy distribution
            const allocationStats = {
                contiguous: 0,
                linked: 0,
                indexed: 0
            };
            
            Object.keys(files).forEach(filePath => {
                const fileInfo = files[filePath];
                if (fileInfo.allocation && fileInfo.allocation.strategy) {
                    allocationStats[fileInfo.allocation.strategy]++;
                }
            });
            
            console.log('Allocation strategy distribution:', allocationStats);
            
            // Calculate stats
            blocks.forEach((block, index) => {
                // Create block element
                const blockEl = document.createElement('div');
                let blockClass = 'empty';
                let blockType = '';
                
                if (block) {
                    usedBlocks++;
                    
                    // Determine block type and assign appropriate class
                    if (block.includes(':index')) {
                        blockClass = 'index-block';
                        blockType = 'Index Block';
                    } else {
                        // Check if this block is part of a specific allocation strategy
                        let linkedBlock = false;
                        let indexedBlock = false;
                          // Check allocation strategy by examining files
                        Object.keys(files).forEach(filePath => {
                            const fileInfo = files[filePath];
                            if (fileInfo.allocation) {
                                // Check if this block belongs to a linked allocation file
                                if (fileInfo.allocation.strategy === 'linked' && 
                                    fileInfo.allocation.blocks && 
                                    fileInfo.allocation.blocks.includes(index)) {
                                    linkedBlock = true;
                                } 
                                // Check if this is the file path block
                                else if (block === filePath) {
                                    if (fileInfo.allocation.strategy === 'linked') {
                                        linkedBlock = true;
                                    } else if (fileInfo.allocation.strategy === 'indexed') {
                                        indexedBlock = true;
                                    }
                                }
                            }
                        });
                          if (linkedBlock) {
                            blockClass = 'linked';
                            blockType = 'Linked Block';
                        } else if (indexedBlock) {
                            blockClass = 'indexed';
                            blockType = 'Indexed Data Block';
                        } else {
                            blockClass = 'allocated';
                            blockType = 'Contiguous Block';
                        }
                    }
                      // Extract short identifier from path
                    let shortId = '';
                    if (block.includes('/')) {
                        const parts = block.split('/').filter(Boolean);
                        if (parts.length > 0) {
                            shortId = parts[parts.length - 1].substring(0, 2);
                        }
                    }
                    
                    // For linked blocks, show 'L' prefix for better identification
                    // Only use linkedBlock variable within its defined scope
                    if (blockClass === 'linked') {
                        shortId = 'L:' + (shortId || index);
                    }
                    
                    blockEl.textContent = shortId || index.toString();
                    
                    if (wasLastEmpty && index > 0) {
                        fragmentCount++;
                    }
                    wasLastEmpty = false;
                } else {
                    blockType = 'Empty Block';
                    wasLastEmpty = true;
                }
                
                blockEl.className = `block ${blockClass}`;
                blockEl.dataset.index = index;
                blockEl.dataset.type = blockType;
                  // Add hover info
                blockEl.addEventListener('mouseover', (e) => {
                    if (block) {                        // Find allocation type and file information for this block
                        let blockInfo = block;
                        let fileDetails = '';
                        let fileFound = false;
                        
                        // Create tooltip header with block number
                        let tooltipContent = `<div><strong>Block ${index}:</strong> <span style="color: #ffeb3b; font-weight: bold;">${blockInfo}</span></div>`;
                        
                        // Always display the block value (file path) prominently
                        fileDetails = `<div><strong>Location:</strong> <span style="color: #ffeb3b;">${block}</span></div>`;
                        
                        Object.keys(files).forEach(filePath => {
                            // Check if this block belongs to any file - improved detection logic
                            if (block === filePath || block.startsWith(filePath + ':') || 
                                (files[filePath].allocation && 
                                    ((files[filePath].allocation.strategy === 'contiguous' && 
                                      index >= files[filePath].allocation.startBlock && 
                                      index < files[filePath].allocation.startBlock + files[filePath].allocation.size) ||
                                     (files[filePath].allocation.strategy === 'linked' && 
                                      files[filePath].allocation.blocks && 
                                      files[filePath].allocation.blocks.includes(index)) ||
                                     (files[filePath].allocation.strategy === 'indexed' && 
                                      ((files[filePath].allocation.indexBlock === index) || 
                                       (files[filePath].allocation.dataBlocks && 
                                        files[filePath].allocation.dataBlocks.includes(index))))
                                ))) {
                                fileFound = true;
                                const fileInfo = files[filePath];
                                const blockType = blockEl.dataset.type;
                                
                                fileDetails += `
                                    <div><strong>File:</strong> <span style="color: #ffeb3b;">${filePath}</span></div>
                                    <div><strong>Block Type:</strong> ${blockType}</div>
                                    <div><strong>Size:</strong> ${fileInfo.content.length.toLocaleString()} bytes</div>
                                `;
                                
                                if (fileInfo.allocation) {
                                    const strategy = fileInfo.allocation.strategy;
                                    fileDetails += `<div><strong>Strategy:</strong> <span style="text-transform: capitalize">${strategy}</span></div>`;
                                    
                                    // Add more detailed allocation information based on strategy
                                    if (strategy === 'contiguous') {
                                        fileDetails += `<div><strong>Start Block:</strong> ${fileInfo.allocation.startBlock}</div>`;
                                        fileDetails += `<div><strong>Block Count:</strong> ${fileInfo.allocation.size}</div>`;
                                        fileDetails += `<div><strong>End Block:</strong> ${fileInfo.allocation.startBlock + fileInfo.allocation.size - 1}</div>`;
                                    } else if (strategy === 'linked') {
                                        fileDetails += `<div><strong>Linked Blocks:</strong> ${fileInfo.allocation.blocks.length}</div>`;
                                    } else if (strategy === 'indexed') {
                                        fileDetails += `<div><strong>Index Block:</strong> ${fileInfo.allocation.indexBlock}</div>`;
                                        fileDetails += `<div><strong>Data Blocks:</strong> ${fileInfo.allocation.dataBlocks.length}</div>`;
                                    }
                                }
                            }
                        });
                        
                        tooltipEl.innerHTML = tooltipContent + fileDetails;
                        tooltipEl.style.opacity = '1';
                        positionTooltip(e); // Position tooltip within viewport
                    } else {
                        tooltipEl.innerHTML = `<div>Block ${index}: Empty</div>`;
                        tooltipEl.style.opacity = '1';
                        positionTooltip(e); // Position tooltip within viewport
                    }
                });
                
                blockEl.addEventListener('mouseout', () => {
                    tooltipEl.style.opacity = '0';
                });
                
                memoryGridEl.appendChild(blockEl);
            });
            
            // Count blocks by allocation type
            let contiguousCount = 0;
            let linkedCount = 0;
            let indexedDataCount = 0;
            let indexBlockCount = 0;
              // Count blocks by type
            console.log('Counting blocks by allocation type...');
            Object.keys(files).forEach(filePath => {
                const fileInfo = files[filePath];
                if (fileInfo.allocation) {
                    const strategy = fileInfo.allocation.strategy;
                    console.log(`File ${filePath} uses ${strategy} allocation`);
                    
                    if (strategy === 'contiguous') {
                        contiguousCount += fileInfo.allocation.size;
                        console.log(`  Added ${fileInfo.allocation.size} contiguous blocks, total: ${contiguousCount}`);
                    } else if (strategy === 'linked') {
                        const blockCount = fileInfo.allocation.blocks.length;
                        linkedCount += blockCount;
                        console.log(`  Added ${blockCount} linked blocks, total: ${linkedCount}`);
                        console.log(`  Linked blocks: ${fileInfo.allocation.blocks.join(', ')}`);
                    } else if (strategy === 'indexed') {
                        const dataCount = fileInfo.allocation.dataBlocks.length;
                        indexedDataCount += dataCount;
                        indexBlockCount++; // Count each index block
                        console.log(`  Added ${dataCount} indexed data blocks and 1 index block, total: ${indexedDataCount} data, ${indexBlockCount} index`);
                    }
                }
            });
              // Update stats
            const freeBlocks = totalBlocks - usedBlocks;
            const totalSizeKB = totalBlocks; // Since 1 block = 1 KB
            const usedPercent = totalBlocks > 0 ? Math.round((usedBlocks / totalBlocks) * 100) : 0;
            const freePercent = totalBlocks > 0 ? Math.round((freeBlocks / totalBlocks) * 100) : 0;
              // Update display elements
            totalBlocksEl.textContent = totalBlocks;
            document.getElementById('totalSizeKB').textContent = totalSizeKB;
            usedBlocksEl.textContent = usedBlocks;
            document.getElementById('usedPercent').textContent = `${usedPercent}%`;
            freeBlocksEl.textContent = freeBlocks;
            document.getElementById('freePercent').textContent = `${freePercent}%`;
            
            // Update allocation type counts
            contiguousBlocksEl.textContent = contiguousCount;
            linkedBlocksEl.textContent = linkedCount;
            indexedDataBlocksEl.textContent = indexedDataCount;
            indexBlocksEl.textContent = indexBlockCount;
            
            // Log the final allocation counts
            console.log('Final allocation counts:');
            console.log(`  Contiguous blocks: ${contiguousCount}`);
            console.log(`  Linked blocks: ${linkedCount}`);
            console.log(`  Indexed data blocks: ${indexedDataCount}`);
            console.log(`  Index blocks: ${indexBlockCount}`);
            
            // Calculate fragmentation
            // Fragmentation is measured by the number of transitions between allocated and free blocks
            const fragmentation = usedBlocks > 0 ? Math.min(100, Math.round((fragmentCount / usedBlocks) * 100)) : 0;
            fragmentationEl.textContent = `${fragmentation}%`;
            
            // Store file data for filtering and sorting
            fileData = [];
            
            // Process file information
            Object.keys(files).forEach(filePath => {
                const fileInfo = files[filePath];
                
                // Calculate allocation efficiency
                const contentSizeKB = (fileInfo.content.length / 1024).toFixed(2);
                const contentSizeBlocks = Math.ceil(fileInfo.content.length / 1024);
                let allocatedBlocks = 0;
                let utilizationRate = 0;
                let allocationInfo = 'No allocation information';
                let allocationClass = '';
                let strategy = 'none';
                
                if (fileInfo.allocation) {
                    strategy = fileInfo.allocation.strategy;
                    
                    if (strategy === 'contiguous') {
                        allocatedBlocks = fileInfo.allocation.size;
                        allocationInfo = `
                            <div class="allocation-info contiguous">
                                <strong>Contiguous Allocation</strong>
                                <div>Start Block: ${fileInfo.allocation.startBlock}</div>
                                <div>Blocks Used: ${fileInfo.allocation.size}</div>
                            </div>
                        `;
                        allocationClass = 'contiguous';
                    } else if (strategy === 'linked') {
                        allocatedBlocks = fileInfo.allocation.blocks.length;
                        const blocksList = fileInfo.allocation.blocks.length <= 10 
                            ? fileInfo.allocation.blocks.join(', ')
                            : fileInfo.allocation.blocks.slice(0, 10).join(', ') + '... (more)';
                        
                        allocationInfo = `
                            <div class="allocation-info linked">
                                <strong>Linked Allocation</strong>
                                <div>Blocks Used: ${fileInfo.allocation.blocks.length}</div>
                                <div>Block Indices: ${blocksList}</div>
                            </div>
                        `;
                        allocationClass = 'linked';
                    } else if (strategy === 'indexed') {
                        allocatedBlocks = fileInfo.allocation.dataBlocks.length + 1; // +1 for index block
                        const blocksList = fileInfo.allocation.dataBlocks.length <= 10 
                            ? fileInfo.allocation.dataBlocks.join(', ')
                            : fileInfo.allocation.dataBlocks.slice(0, 10).join(', ') + '... (more)';
                            
                        allocationInfo = `
                            <div class="allocation-info indexed">
                                <strong>Indexed Allocation</strong>
                                <div>Index Block: ${fileInfo.allocation.indexBlock}</div>
                                <div>Data Blocks: ${fileInfo.allocation.dataBlocks.length}</div>
                                <div>Block Indices: ${blocksList}</div>
                            </div>
                        `;
                        allocationClass = 'indexed';
                    }
                    
                    // Calculate utilization rate (content size vs allocated space)
                    utilizationRate = ((fileInfo.content.length / (allocatedBlocks * 1024)) * 100).toFixed(1);
                }
                
                // Store file data for filtering and sorting
                fileData.push({
                    path: filePath,
                    name: filePath.split('/').pop(),
                    contentSize: fileInfo.content.length,
                    contentSizeKB,
                    contentSizeBlocks,
                    allocatedBlocks,
                    utilizationRate,
                    strategy,
                    allocationClass,
                    allocationInfo,
                    html: `
                        <div class="file-header ${allocationClass}">
                            <strong>${filePath}</strong>
                            <div class="file-stats">
                                <span>${contentSizeKB} KB (${fileInfo.content.length} bytes)</span>
                                <span>Needed blocks: ${contentSizeBlocks}</span>
                                <span>Allocated blocks: ${allocatedBlocks}</span>
                                <span>Utilization: ${utilizationRate}%</span>
                            </div>
                        </div>
                        ${allocationInfo}
                    `
                });
            });
            
            // Render file list with current filter/sort settings
            renderFileList();
        }
        
        // Function to render file list with filtering and sorting
        function renderFileList() {
            const searchTerm = fileSearchEl.value.toLowerCase();
            const sortBy = fileSortEl.value;
            
            // Filter files based on search term
            let filteredFiles = fileData.filter(file => {
                return file.path.toLowerCase().includes(searchTerm) || 
                       file.strategy.toLowerCase().includes(searchTerm);
            });
            
            // Sort files based on selected option
            filteredFiles.sort((a, b) => {
                switch (sortBy) {
                    case 'name':
                        return a.path.localeCompare(b.path);
                    case 'size':
                        return b.contentSize - a.contentSize;
                    case 'strategy':
                        return a.strategy.localeCompare(b.strategy);
                    case 'blocks':
                        return b.allocatedBlocks - a.allocatedBlocks;
                    default:
                        return 0;
                }
            });
            
            // Clear file list
            fileListEl.innerHTML = '';
            
            // No files message
            if (filteredFiles.length === 0) {
                fileListEl.innerHTML = '<div style="padding: 15px; text-align: center;">No files found</div>';
                return;
            }
            
            // Render files
            filteredFiles.forEach(file => {
                const fileEl = document.createElement('div');
                fileEl.className = 'file-item';
                fileEl.innerHTML = file.html;
                fileListEl.appendChild(fileEl);
            });
        }
        
        // Get memory data from main process
        function refreshMemoryView() {
            console.log('Requesting memory data...');
            try {
                ipcRenderer.send('get-memory-data');
                // Tambahkan indikator loading
                memoryGridEl.innerHTML = '<div style="text-align: center; padding: 20px;">Loading memory data...</div>';
            } catch (err) {
                console.error('Error requesting memory data:', err);
                memoryGridEl.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">Error: ${err.message}</div>`;
            }
        }
        
        // Listen for memory data
        ipcRenderer.on('memory-data', (event, data) => {
            console.log('Received memory data:', data);
            try {
                if (!data || !data.blocks) {
                    console.error('Invalid memory data received:', data);
                    memoryGridEl.innerHTML = '<div style="color: red; text-align: center; padding: 20px;">Error: Invalid memory data</div>';
                    return;
                }
                renderMemoryGrid(data);
            } catch (err) {
                console.error('Error rendering memory grid:', err);
                memoryGridEl.innerHTML = `<div style="color: red; text-align: center; padding: 20px;">Error: ${err.message}</div>`;
            }
        });
        
        // Refresh button click
        refreshBtn.addEventListener('click', refreshMemoryView);
        
        // Run Test button click
        runTestBtn.addEventListener('click', async () => {
            testStatusEl.textContent = 'Running tests...';
            testStatusEl.className = 'test-status running';
            
            try {
                const result = await memoryTest.runMemoryVisualizationTest();
                
                if (result.success) {
                    testStatusEl.textContent = 'Tests completed successfully. Refreshing view...';
                    testStatusEl.className = 'test-status success';
                    setTimeout(refreshMemoryView, 1000);
                } else {
                    testStatusEl.textContent = `Error: ${result.error}`;
                    testStatusEl.className = 'test-status error';
                }
            } catch (error) {
                console.error('Error running tests:', error);
                testStatusEl.textContent = `Error: ${error.message}`;
                testStatusEl.className = 'test-status error';
            }
        });
          // Position tooltip to ensure it stays within viewport
        function positionTooltip(e) {
            const tooltip = tooltipEl;
            const margin = 12;
            
            // Make the tooltip visible but not opaque to get its dimensions
            tooltip.style.opacity = '0.01';
            tooltip.style.display = 'block';
            
            // Get coordinates
            let x = e.pageX + margin;
            let y = e.pageY + margin;
            
            // Get tooltip dimensions after rendering
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Default position is to the right of cursor
            // If too close to right edge, position to the left of cursor
            if (x + tooltipWidth > viewportWidth - margin) {
                x = e.pageX - tooltipWidth - margin;
            }
            
            // If too close to bottom edge, position above cursor
            if (y + tooltipHeight > viewportHeight - margin) {
                y = e.pageY - tooltipHeight - margin;
            }
            
            // Final safety check - ensure tooltip is not positioned off any edge
            x = Math.max(margin, Math.min(x, viewportWidth - tooltipWidth - margin));
            y = Math.max(margin, Math.min(y, viewportHeight - tooltipHeight - margin));
            
            // Set the final position
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
            tooltip.style.opacity = '1';
        }
        
        // Search and sort files
        function filterAndSortFiles(files) {
            let filteredFiles = Object.keys(files).filter(filePath => {
                const fileInfo = files[filePath];
                const searchTerm = fileSearchEl.value.toLowerCase();
                
                // Filter by search term in file name or allocation strategy
                return filePath.toLowerCase().includes(searchTerm) || 
                       (fileInfo.allocation && fileInfo.allocation.strategy.toLowerCase().includes(searchTerm));
            });
            
            // Sort files based on selected criteria
            const sortBy = fileSortEl.value;
            filteredFiles.sort((a, b) => {
                const fileA = files[a];
                const fileB = files[b];
                
                if (sortBy === 'name') {
                    return a.localeCompare(b);
                } else if (sortBy === 'size') {
                    return (fileA.content.length - fileB.content.length);
                } else if (sortBy === 'strategy') {
                    const strategyA = fileA.allocation ? fileA.allocation.strategy : '';
                    const strategyB = fileB.allocation ? fileB.allocation.strategy : '';
                    return strategyA.localeCompare(strategyB);
                } else if (sortBy === 'blocks') {
                    const blocksA = fileA.allocation ? fileA.allocation.size : 0;
                    const blocksB = fileB.allocation ? fileB.allocation.size : 0;
                    return (blocksA - blocksB);
                }
                
                return 0;
            });
            
            return filteredFiles;
        }
        
        // Update file list display
        function updateFileListDisplay(files) {
            // Clear existing file list
            fileListEl.innerHTML = '';
            
            // Render each file in the list
            files.forEach(filePath => {
                const fileInfo = files[filePath];
                const fileEl = document.createElement('div');
                fileEl.className = 'file-item';
                
                // Calculate allocation efficiency
                const contentSizeKB = (fileInfo.content.length / 1024).toFixed(2);
                const contentSizeBlocks = Math.ceil(fileInfo.content.length / 1024);
                let allocatedBlocks = 0;
                let utilizationRate = 0;
                let allocationInfo = 'No allocation information';
                let allocationClass = '';
                
                if (fileInfo.allocation) {
                    if (fileInfo.allocation.strategy === 'contiguous') {
                        allocatedBlocks = fileInfo.allocation.size;
                        allocationInfo = `
                            <div class="allocation-info contiguous">
                                <strong>Contiguous Allocation</strong>
                                <div>Start Block: ${fileInfo.allocation.startBlock}</div>
                                <div>Blocks Used: ${fileInfo.allocation.size}</div>
                            </div>
                        `;
                        allocationClass = 'contiguous';
                    } else if (fileInfo.allocation.strategy === 'linked') {
                        allocatedBlocks = fileInfo.allocation.blocks.length;
                        const blocksList = fileInfo.allocation.blocks.length <= 10 
                            ? fileInfo.allocation.blocks.join(', ')
                            : fileInfo.allocation.blocks.slice(0, 10).join(', ') + '... (more)';
                        
                        allocationInfo = `
                            <div class="allocation-info linked">
                                <strong>Linked Allocation</strong>
                                <div>Blocks Used: ${fileInfo.allocation.blocks.length}</div>
                                <div>Block Indices: ${blocksList}</div>
                            </div>
                        `;
                        allocationClass = 'linked';
                    } else if (fileInfo.allocation.strategy === 'indexed') {
                        allocatedBlocks = fileInfo.allocation.dataBlocks.length + 1; // +1 for index block
                        const blocksList = fileInfo.allocation.dataBlocks.length <= 10 
                            ? fileInfo.allocation.dataBlocks.join(', ')
                            : fileInfo.allocation.dataBlocks.slice(0, 10).join(', ') + '... (more)';
                            
                        allocationInfo = `
                            <div class="allocation-info indexed">
                                <strong>Indexed Allocation</strong>
                                <div>Index Block: ${fileInfo.allocation.indexBlock}</div>
                                <div>Data Blocks: ${fileInfo.allocation.dataBlocks.length}</div>
                                <div>Block Indices: ${blocksList}</div>
                            </div>
                        `;
                        allocationClass = 'indexed';
                    }
                    
                    // Calculate utilization rate (content size vs allocated space)
                    utilizationRate = ((fileInfo.content.length / (allocatedBlocks * 1024)) * 100).toFixed(1);
                }
                
                fileEl.innerHTML = `
                    <div class="file-header ${allocationClass}">
                        <strong>${filePath}</strong>
                        <div class="file-stats">
                            <span>${contentSizeKB} KB (${fileInfo.content.length} bytes)</span>
                            <span>Needed blocks: ${contentSizeBlocks}</span>
                            <span>Allocated blocks: ${allocatedBlocks}</span>
                            <span>Utilization: ${utilizationRate}%</span>
                        </div>
                    </div>
                    ${allocationInfo}
                `;
                fileListEl.appendChild(fileEl);
            });
        }
        
        // Search input event
        fileSearchEl.addEventListener('input', () => {
            const filteredFiles = filterAndSortFiles(files);
            updateFileListDisplay(filteredFiles);
        });
        
        // Sort select change event
        fileSortEl.addEventListener('change', () => {
            const filteredFiles = filterAndSortFiles(files);
            updateFileListDisplay(filteredFiles);
        });
        
        // Initial render
        refreshMemoryView();
        
        // Set an interval to refresh automatically
        setInterval(refreshMemoryView, 5000); // Refresh every 5 seconds
    </script>
</body>
</html>
